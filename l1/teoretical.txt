1. в случае, если нам известна длина строки, 
   то лучший вариант контактенации осуществляется через copy. 
   Однако, буфер (слайс) можно расширить. Это обычно делается через выделение нового среза с большей вместимостью.
  
   Иначе, лучший вариант с помощью bytes.Buffer и её (структуры Buffer) метода WriteString.

2. Интерфейс представляет из себя контракт, определяющий методы, которым обязан обладать объект, удовлетворяющий интерфейсу.
   Интерфейсы используют "для сокрытия" и дальнейшего анонимного употребления методов какого-то класса который был скрыт через интерфейс.
   Также, интерфейсы нужны, чтобы вне зависимости от типа данных принимать какой-либо объект.

3. RWMutex используется, когда параллельное чтение разрешено, мы можем блокировать переменную отдельно на чтение и запись.
   Блокировка на чтение не блокирует чтение в других горутинах, только запись.

4. Запись в буферизированный канал не блокирует горутину, до тех пор, пока не заполнен буфер и не требует обязательного считывания.
   В случае небуферезированного канала, горутина записывающая/считывающая блокируется сразу и считывание из него обязательно.

5. Размер нулевой, отсутвует какой-либо "вес".

6. Перегрузка отсутвует.

7. В случайном в случае range, а случае fmt.Println(map) вывод будет отсортирован по ключам.

8. make() инициализирует срез, канал или мапу. new() аллоцирует память под данные и возвращает указатель.

9. 4 способа задать slice:
   var a []int
   var b []int = []int{1, 2, 3}
   c := []int{1, 2, 3}
   d := []int{1: 12}

   3 способа задать map:
   var users map[string]int
   m1 := make(map[int]int)
   m2 := map[int]int{}

10. Вывод: 1 1. В функцию update указатель передается по значению, это значит, что 
    передастся копия указателя, определенная по другому адресу в памяти.
    В случае обращения к к копии указателя (к новому учатску памяти) в старом указателе (в старом участке памяти),
    находящийся в области видимости main(), ничего не изменится.

11. Случится deadlock. Копируется WaitGroup и копия завершается (wg.Done()), тогда как нужно, чтобы завершилась внешняя WaitGroup. 
    В данном случае следует передать указатель на структуру, а не саму структуру.
   
12. Вывод: 0. Так случилось, так как была в области видимости if{} была создана локальная переменная,
    она же и была изменена, но не переменная в области видимости main().

13. Вывод: 100, 2, 3, 4, 5. someAction() изменяет базовый массив среза, 
    а после присваивает v новый срез с новым базовым массивом.

14. Вывод: ["b", "b", "a"] ["a", "a"]. Анонимная функция внутри main() создает срез с новым базовым массивом и редактирует его, не затрагивая старого.